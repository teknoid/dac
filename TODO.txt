BUGS
--------------------------------------------------------------------------------------------



TODO
--------------------------------------------------------------------------------------------

* mcp.c entrümpeln, kein terminal mehr, kein display mehr etc.

* solar: device und potd config in json ablegen und WebUI dafür bauen

* alles solar* in separates verzeichnis solar/

* alles dac* in separates verzeichnis dac/

* solar: statt 24/7 history und factors calc eine 365 history tabelle und aus dieser den am besten passenden wert +/- 1 Monat um heute nehmen:
	(yday + h), rad1h, sund1, ttt, mppt1, mppt2, mppt3, mppt4  

* Sprachausgabe e.g. confirm("Strahler Bad an")

* sensors: BMP085 neu schreiben

* mqtt.c notifications: ein/aus, temporär aus(?)

* LOCALMAIN's in devinput-*

* switch: on/off zum ES9018 einschalten ohne Fernbedienung
	--> switch.c schon da nur mit compilieren und installieren; umbenennen in dac_power_toggle o.ä

* display:
	* ascii arts: cfire, astreroids etc...

	* clear screen on shutdown

	* setup, playlist play/stop nur zeigen wenn DAC an ist

	* menu timeout geht nicht mehr?

	* system menu:
		- switch mpd source: public / sda
		- enable/disable wlan0
		- enable/disable wifi hotspot for mpdroid
		- switches 1-4
		- wecker stellen

	* idle screen:
		- oben li datum; re Uhr ohne clocktick
		- mitte roating alle 3s via status counter der sich zurücksetzt: kernel version, disk free, uptime, IP addr eth0/wlan0
		- unten li temp sys, temp sda; re load


DONE
----------------------------------------------


solar definitiv
- keine includes sondern .c files die im Makefile je nach target kombiniert werden

- pstate/gstate/counter in eigenes modul auslagern mit gemeinsamen speicher wie bei sensors

- als mcp modul mit init/stop/loop

- init lädt state, stop sichert state

- zeitkritisch! loop macht jede sekunde nur aggregate und die calculates und schreibt in die pstate/gstate/counter current

- nächste sekunde abwarten mit while / msleep(100)

- epoche sekunden modulo 60 -> minly, modulo 3600 -> hourly modulo 86400 -> daily
	*now wird eh gebraucht - nicht nötig

- rest in eigenes modul auslagern (device / dispatcher) - dieser macht dann reponse / ramp / standby und die cron sachen

- ebenfals als mcp modul, hauptsache loop, hier ist dann die laufzeit unkritisch, zB. sleep(5)


* Fronius auslesen

* flamingo realtime

* input selector ausprogrammieren

* vol++ vol-- input: kurz fullscreen grafik einblenden mit anzeige
	- digitalanzeige 7x4 in ascii arts
	- counter zählt rückwärts, wenn 0 wieder auf normalanzeige schalten, erneutes +/- setzt counter wieder zurück

* verschiedene screens ON OFF STDBY NIGHT usw. 

* artist+title: mittig und scroll wenn > 20

* night mode

* global status struct status_t, dort auch power integrieren, enum für signal

* Temp gelb von 40-50

* bits auslesen (MPD)

* beim start MPD status abfragen
